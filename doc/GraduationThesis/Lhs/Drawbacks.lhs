
Chapter 4, \textit{Enlightenment}, explained how to execute the simulation using a function as the driver. Later, a guided example was provided to grasp how the side effects and the implicit recursion are capable of solving --- via the \texttt{Integrator} and \texttt{Dynamics} types --- differential equations. This chapter will show some graphs to evaluate if the generated results actually match reality, i.e., check if the answers portray physical phenomena within acceptable approximations. At the end, two major concerns will be identified for further investigation in chapter 6, \textit{Weakening Discreteness}, and in chapter 7, \textit{The Speed Pill: Caching}.

\section{Lorenz's Butterfly}

After all the explained theory behind the project, it reamins to be seen if this can be converted into practical results. In certain constant values, the generated graph of the Lorenz's Attractor example used in the last chapter is known for stability and getting the shape of two fixed point attractors, meaning that the system evolves to a stable state even if slightly disturbed. As showed in Figure \ref{fig:lorenzPlots}, the obtained graph from the Lorenz's Attractor model matches what was expected for a Lorenz's system. It is worth noting that changing the values of $\sigma$, $\rho$ and $\beta$ can produce completely different answers, destroying the resembled "butterfly" shape of the graph.

\begin{figure}[ht!]
\begin{minipage}{.60\textwidth}
\begin{center}
  \includegraphics[width=1.0\linewidth]{GraduationThesis/img/LorenzPlot1}
\end{center}
\end{minipage}
\begin{minipage}{.39\textwidth}
\begin{center}
  \includegraphics[width=1.0\linewidth]{GraduationThesis/img/LorenzPlot2}
\end{center}
\end{minipage}
\caption{The Lorenz's Attractor example has a very famous butterfly shape from certain angles and constant values in the graph generated by the solution of the differential equations.}
\label{fig:lorenzPlots}
\end{figure}

Although correct, the presented solution has a few drawbacks. The first one araises from performance: how much \textbf{time} it takes to compute? The second comes a small implementation detail that was not taken into account during implementation: what about points that are not multiple of the time step. These two questions will be explained in detail in the next two sections.

\section{Time Step's In-betweens}

The second drawback is related to the time steps and the stop time the user is interested in. As explained in the previous chapters, the size of the time step is used across the simulation to walk through the iteration axis, a discrete version of the time axis. Hence, this size interfers with which interval of time the integrator is capable of computing, given that it is limited to values that are \textbf{multiple} of the size of the time step. This means that multiple end points will generate the same answer, affecting the accuracy of the simulator.



\section{Sluggishness}

The first encountered issue is related to performance; the simulation takes too \textbf{long} to execute. For instance, to execute the Lorenz's Attractor example with an unreasonable time step size of 1, the simulator can take around \textbf{10 seconds} to compute in modern hardware an interval of 0 to 5 seconds of the physical system. Increasing this interval shows an exponencitial growth in execution time, as depicted by the table in Table \ref{tab:execTimes}. Thus, with this exponentinal growth, it is totally impractical to execute longer simulations, diminishing the usability of the proposed software.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
Stop Time (seconds) & Execution Time (seconds) \\ \hline
5                   & 9.69                     \\ \hline
6                   & 124.63                   \\ \hline
7                   & 1584.56                  \\ \hline
8                   & 19970.17                 \\ \hline
\end{tabular}
\caption{\label{tab:execTimes}Small increases in the stop time of the simulation provoke exponential penalties in performance. The above values were obtained in a compouter running a 6-th quad-core \texttt{i5} Intel processor.}
\end{table}

These two problems cripple the potential uses cases for \texttt{Rivika}, given that we cannot always trust its results due to dependency in the used time step size, and maybe we can't even foresee the acquired results within deadlines, because its time execution time growths exponentially. The next chapters will not only explain the origin of these concerns, but will also totally address them. After these tweaks, very granular time steps sizes will be available for use, as well as not \texttt{Rivika} will depend less on the size of the time step to execute integrals.
