\babel@toc {american}{}
\babel@toc {american}{}
\babel@toc {american}{}
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {2.1}{\ignorespaces Types are not just labels; they enhance the manipulated data with new information. Their difference in shape can work as the interface of the data.\relax }}{3}{figure.caption.7}%
\contentsline {figure}{\numberline {2.2}{\ignorespaces Functions' signatures are contracts; they specify which shape the input information has as well as which shape the output information will have.\relax }}{3}{figure.caption.7}%
\contentsline {figure}{\numberline {2.3}{\ignorespaces Sum types can be understood in terms of sets, in which the members of the set are available candidates for the outer shell type. Parity and possible values in digital states are examples.\relax }}{4}{figure.caption.8}%
\contentsline {figure}{\numberline {2.4}{\ignorespaces Product types are a combination of different sets, where you pick a representative from each one. Digital clocks' time and objects' coordinates in space are common use cases. In Haskell, a product type can be defined using a \textbf {record} alongside with the constructor, where the labels for each member inside it are explicit.\relax }}{5}{figure.caption.9}%
\contentsline {figure}{\numberline {2.5}{\ignorespaces Depending on the application, different representations of the same structure need to used due to the domain of interest and/or memory contraints.\relax }}{5}{figure.caption.10}%
\contentsline {figure}{\numberline {2.6}{\ignorespaces The minimum requirement for the \texttt {Ord} typeclass is the $<=$ operator, meaning that the functions $<$, $<=$, $>$, $>=$, \texttt {max} and \texttt {min} are now unlocked for the type \texttt {ClockTime} after the implementation.\relax }}{6}{figure.caption.11}%
\contentsline {figure}{\numberline {2.7}{\ignorespaces Replacements of the validation function within a pipeline like the above is common.}}{6}{figure.caption.12}%
\contentsline {figure}{\numberline {2.8}{\ignorespaces The initial value is used as a starting point for the procedure. The algorithm continues until the time of interest is reached in the unknown function. Due to its large time step, the final answer is really far-off from the expected result.\relax }}{8}{figure.caption.13}%
\contentsline {figure}{\numberline {2.9}{\ignorespaces In Haskell, the \texttt {type} keyword works for alias. The first draft of the \texttt {Dynamics} type is a \textbf {function}, in which providing a floating point value as time returns another value as outcome.\relax }}{9}{figure.caption.14}%
\contentsline {figure}{\numberline {2.10}{\ignorespaces The \texttt {Parameters} type represents a given moment in time, carrying over all the necessary information to execute a solver step until the time limit is reached. Some useful typeclasses are being derived to these types, given that Haskell is capable of infering the implementation of typeclasses in simple cases.\relax }}{9}{figure.caption.15}%
\contentsline {figure}{\numberline {2.11}{\ignorespaces The \texttt {Dynamics} type is a function of from time related information to an arbitraty outcome value.\relax }}{10}{figure.caption.16}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces Tthe \textit {fmap} function applies a pure function, \textit {f}, to the output value of a given \texttt {Dynamics}. Also, because the final value is wrapped in the \texttt {IO} monad, it is necessary to use its own \textit {fmap}, meaning that the one on the left is different from the one on the right; each \textit {fmap} corresponds to a different type.\relax }}{12}{figure.caption.17}%
\contentsline {figure}{\numberline {3.2}{\ignorespaces With the \texttt {Applicative} typeclass, it is possible to \textbf {compose} \texttt {Dynamics} types. The pure function wrapped with the type can be correctly plumbered to the second value inside the same shell type, generating the result.\relax }}{13}{figure.caption.18}%
\contentsline {figure}{\numberline {3.3}{\ignorespaces The \texttt {Monad} typeclass does a different sort of \texttt {Dynamics} composition. With monads, it is possible to use a sytax sugar called \texttt {do} notation, which allows the developer to \textbf {unwrapp} a given type. In the implementation, this is being used to unwrapped the \texttt {IO} monad at the end of line 2 of the \textit {bind} function. After the $\leftarrow $ operator, the value \texttt {a} is not surrounded by \texttt {IO}.\relax }}{14}{figure.caption.19}%
\contentsline {figure}{\numberline {3.4}{\ignorespaces The typeclass \texttt {MonadIO} transforms a given value wrapped in \texttt {IO} into a different monad. In this case, the parameter of the function is the output of the \texttt {Dynamics} type.\relax }}{14}{figure.caption.20}%
\contentsline {figure}{\numberline {3.5}{\ignorespaces To make binary and tertiary operations to work, it is necessary to wrapped the operands with the desired type, \texttt {Dynamics} in this case. The implementation of \textit {liftOP2}, which has the signature $(a \rightarrow b \rightarrow c) \rightarrow Dynamics\tmspace +\thickmuskip {.2777em} a \rightarrow Dynamics\tmspace +\thickmuskip {.2777em} b \rightarrow Dynamics\tmspace +\thickmuskip {.2777em} c$, is analogous.\relax }}{14}{figure.caption.21}%
\contentsline {figure}{\numberline {3.6}{\ignorespaces State Machines are a common abstraction in computer science due to its easy mapping between function calls and states. Memory regions and periphals are embedded with the idea of a state, not only pure functions. Further, side-effects can even act as the trigger to move from one state to another, meaning that executing a simple function can do more than return a value. Its internal guts can signicantly modify the state machine.\relax }}{15}{figure.caption.22}%
\contentsline {figure}{\numberline {3.7}{\ignorespaces Illustration of the current state of the integrator's pointer after the \textit {diffInteg} function. What's being pointed involves the same pointer again recursively..}}{18}{figure.caption.23}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {4.1}{\ignorespaces The \texttt {Traverse} typeclass allows the type to use the \textit {traverse} and \textit {sequence} function, in which both are related to apply inversion with structured data..}}{22}{figure.caption.24}%
\contentsline {figure}{\numberline {4.2}{\ignorespaces When building a model for simulation, the above pipeline is always used. After managing the integrator, switch the order of the shells using \textit {sequence} and wrap everything in \texttt {Dynamics} using \textit {return}.\relax }}{22}{figure.caption.25}%
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\babel@toc {american}{}
\babel@toc {american}{}
\babel@toc {american}{}
\babel@toc {american}{}
